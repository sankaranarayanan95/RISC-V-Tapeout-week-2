# 🧩 Week 3 Task 1 — Post-Synthesis Gate-Level Simulation (GLS) 🚀

---

## 🎯 **Objective**

The goal is to perform **Gate-Level Simulation (GLS)** for the **BabySoC** design post-synthesis, ensuring the synthesized netlist retains the same functionality as the RTL model. This task also provides hands-on experience in post-synthesis verification.

---

## 🧠 **Theoretical Overview**

### 🔹 **1. What is Gate-Level Simulation?**
Gate-Level Simulation (GLS) involves simulating the **synthesized netlist** generated after logic synthesis. It verifies:
- **Functional equivalence** between the RTL and synthesized designs.
- Correct **clock, reset, and logic behavior** post-synthesis.
- Optional **timing behavior** validation using Standard Delay Format (SDF).

### 🔹 **2. Why Perform GLS?**
GLS is critical to:
- Confirm **functional equivalence** between RTL and gate-level designs.
- Ensure **clock and reset integrity** after synthesis.
- Build confidence before proceeding to layout and Static Timing Analysis (STA).

### 🔹 **3. Inputs to GLS**

| **File Type**                | **Description**                                                                 |
|------------------------------|---------------------------------------------------------------------------------|
| `vsdbabysoc_netlist.v`       | Synthesized gate-level Verilog netlist generated by Yosys.                      |
| `testbench.v`                | Testbench used for both pre-synthesis and post-synthesis simulations.           |
| Standard Cell Library (`.lib`) | Library used during synthesis to map logic gates.                               |

---

## 🧰 **Environment Setup**

### 🗂 **Directory Structure**

```
VSDBabySoC/
├── src/
│   ├── include/
│   └── module/
│       ├── vsdbabysoc.v
│       ├── rvmyth.v
│       ├── testbench.v
│       └── <other RTL modules>
└── output/
    ├── pre_synth_sim/
    ├── synth/
    ├── gls/
    └── sta/
```

### 🛠 **Tools Used**

| **Tool**              | **Purpose**                          |
|-----------------------|--------------------------------------|
| **Icarus Verilog**    | RTL and GLS simulation              |
| **Yosys**             | Logic synthesis                     |
| **GTKWave**           | Waveform visualization              |
| **OpenSTA**           | Static Timing Analysis (Part 2)     |

---

## ⚙️ **Step-by-Step Procedure**

### 🧭 **Step 1: Perform RTL (Pre-Synthesis) Simulation**

Verify the RTL design functionality before synthesis.

```bash
iverilog -o output/pre_synth_sim/pre_synth_sim.out \
    -DPRE_SYNTH_SIM \
    -I src/include -I src/module \
    src/module/testbench.v src/module/vsdbabysoc.v
cd output/pre_synth_sim
./pre_synth_sim.out
```

**Visualize the waveform:**

```bash
gtkwave pre_synth_sim.vcd
```

✅ **Expected Output**:  
Functional waveform showing correct BabySoC behavior with valid logic transitions.

---

### 🧮 **Step 2: Synthesize the Design (Using Yosys)**

Launch Yosys and execute the synthesis script:

```bash
yosys
```

**Synthesis Script:**

```tcl
# --- Synthesis Script ---
read_verilog src/module/vsdbabysoc.v
read_verilog src/module/rvmyth.v
synth -top vsdbabysoc
write_verilog output/synth/vsdbabysoc_netlist.v
write_sdf output/synth/vsdbabysoc.sdf
exit
```

✅ **Generated Files**:
- `output/synth/vsdbabysoc_netlist.v` → Gate-level netlist
- `output/synth/vsdbabysoc.sdf` → Standard Delay Format file (for STA)

---

### 🧠 **Step 3: Run Post-Synthesis (GLS) Simulation**

Simulate the synthesized netlist using the same testbench.

```bash
iverilog -o output/gls/gls.out \
    -DPOST_SYNTH_SIM \
    -I src/include -I src/module \
    src/module/testbench.v output/synth/vsdbabysoc_netlist.v
cd output/gls
./gls.out
```

✅ **Generated Output**:  
`gls.vcd` — Waveform file showing post-synthesis signal transitions.

---

### 🔬 **Step 4: Compare Results**

Open and compare pre-synthesis and GLS waveforms:

```bash
gtkwave output/pre_synth_sim/pre_synth_sim.vcd &
gtkwave output/gls/gls.vcd &
```

**Comparison Focus**:
- Signal behavior
- Output timing
- Logic transitions

✅ **Expected Result**:  
Both waveforms should be **functionally identical**, confirming synthesis correctness.

---

## 📊 **Results & Observations**

| **Parameter**            | **Pre-Synthesis (RTL)** | **Post-Synthesis (GLS)** | **Remarks**                          |
|--------------------------|-------------------------|--------------------------|--------------------------------------|
| **Simulation Model**     | Behavioral (RTL)        | Structural (Gate-Level) |                                      |
| **Waveform Transition**  | ✓ Valid                | ✓ Matches RTL           | Functionally equivalent             |
| **Functionality**        | Correct                 | Preserved               | No synthesis-induced discrepancies  |
| **Timing (Delays)**      | Ideal                   | Gate-based              | Reflects synthesis delays           |
| **Clock/Reset Behavior** | Stable                  | Stable                  | Consistent behavior                 |

**Observation**:  
The GLS waveform aligns perfectly with the RTL waveform, validating the synthesis process and ensuring functional equivalence.

---

## 🧾 **Deliverables**

1. **Synthesis Log**  
   - File: `output/synth/yosys_synth.log`

2. **GLS Waveform Screenshot**  
   - File: `output/gls/gls_waveform.png`

3. **Pre-Synthesis Waveform Screenshot**  
   - File: `output/pre_synth_sim/pre_synth_waveform.png`

4. **Short Note**  
   > The Gate-Level Simulation (GLS) output matches the pre-synthesis RTL simulation output, confirming that the BabySoC synthesized netlist preserves the intended functionality with no synthesis-induced discrepancies.

---

## 📚 **References**

- [VSD HDP - GLS Reference](https://example.com/vsd-hdp-gls)
- [Yosys Open Synthesis Suite](https://yosyshq.net/yosys/)
- [GTKWave Viewer](https://gtkwave.sourceforge.net/)
- [OpenSTA for Timing Analysis](https://github.com/The-OpenROAD-Project/OpenSTA)

---

## 🧑‍💻 **Author**

**Sankararayanan V.**

---

> **Note**: This task enhances understanding of post-synthesis verification, ensuring robust design validation before proceeding to physical design stages. 🚀
